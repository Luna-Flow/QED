#set page(paper: "a4", margin: (x: 2.4cm, y: 2.2cm))
#set par(justify: true, leading: 0.62em)
#set text(size: 10.5pt)

#let info-color = rgb("#1d4ed8")
#let warning-color = rgb("#ca8a04")
#let critical-color = rgb("#b91c1c")

#let level-color(level) = {
  if level == "info" {
    info-color
  } else if level == "warning" {
    warning-color
  } else {
    critical-color
  }
}

#let keyblock(level, title, body) = {
  let color = level-color(level)
  rect(
    inset: 10pt,
    radius: 5pt,
    stroke: 0.5pt + color,
    fill: color.lighten(86%),
    [
      #text(fill: color)[#title]
      #v(0.35em)
      #body
    ],
  )
}

#align(center)[
  #text(size: 16pt)[A Formal Mathematical Specification for QED]
  #linebreak()
  #text(size: 11pt)[A Minimal LCF-Style HOL Kernel in MoonBit]
]

#v(1.2em)

= Abstract

This document presents a formal specification for QED, a theorem prover built in MoonBit and inspired by the LCF architecture of HOL Light. The purpose is to define precise mathematical objects, trusted inference rules, and correctness obligations before large-scale tactic and automation layers are introduced. The long-term target is a complete paper-like artifact that can be read independently of the implementation details.

#v(0.8em)
#keyblock("info", [Scope Statement], [
The present version specifies the core kernel language of simple types and terms, the theorem object, and the primitive inference rules. Parser syntax, interactive shell behavior, and high-level tactic scripts are intentionally excluded from the trusted core.
])

= Foundational Theory

The formal development begins with basic symbols and object formation rules. Higher layers of derived rules and engineering constraints are introduced only after these foundations are fixed.

= Mathematical Preliminaries

Let $Sigma_t$ be a signature of type constructors and $Sigma_c$ a signature of term constants. The distinguished type constructor $"fun"$ has arity $2$, and $"bool"$ has arity $0$.

A type is generated by:
$
  tau ::= alpha \mid k(tau_1, ..., tau_n)
$
where $alpha$ ranges over type variables and $k in Sigma_t$.

A term is generated by:
$
  t ::= x : tau \mid c : tau \mid t_1\ t_2 \mid lambda x{:}tau.\ t
$
with the usual side condition that abstraction binds free occurrences of $x$ in $t$.

= Kernel Data Objects

In the current implementation, the type constructors are represented by two variants:
`TyVal(name)` and `TyApp(tycon, args)`.
The term constructors are:
`Var(name, tau)`, `Const(name, tau)`, `Comb(f, x)`, and `Abs(x, t)`.

#keyblock("warning", [Trusted Boundary], [
The theorem value must remain abstract outside the kernel package. Any external module may consume a theorem but cannot manufacture one except by calling primitive inference functions exported by the kernel.
])

= Typing Discipline

The meta-function `type_of(t)` is total on well-formed terms and must satisfy:

1. `type_of(Var(x, tau)) = tau`.
2. `type_of(Const(c, tau)) = tau`.
3. If `type_of(f) = "fun"(tau_1, tau_2)`, then `type_of(Comb(f, x)) = tau_2`.
4. `type_of(Abs(x, t)) = "fun"(type_of(x), type_of(t))`.

The kernel must reject or mark invalid any construction that violates function-domain compatibility for application.

= Primitive Inference Interface

A theorem is a sequent $Gamma \vdash p$, where $Gamma$ is a finite assumption set and $p$ is a boolean term.

The target primitive rule set follows HOL Light style:
`REFL`, `ASSUME`, `TRANS`, `MK_COMB`, `ABS`, `BETA`, `EQ_MP`, `DEDUCT_ANTISYM_RULE`, `INST_TYPE`, `INST`.

For each primitive rule, two obligations are required:

1. A constructive clause producing a theorem when side conditions hold.
2. A failure clause with explicit error classification when side conditions fail.

= Soundness Obligations

To justify trust in the kernel, QED requires three layers of argument:

1. Local rule soundness: each primitive rule preserves validity under standard HOL semantics.
2. Representation safety: external code cannot create theorem values directly.
3. Composition closure: any derivation tree built from primitive rules remains valid.

#keyblock("critical", [Proof Engineering Note], [
The immediate engineering goal is not a full mechanized meta-proof, but a traceable correspondence between mathematical side conditions and executable guard checks in the MoonBit kernel.
])

= Documentation Program

This file is the seed of a full formal document that will accompany QED. The final target artifact is a complete paper-like mathematical specification, including:

- formal syntax and typing judgments,
- full primitive rule definitions with side conditions,
- theorem object abstraction argument,
- substitution and alpha-equivalence lemmas,
- consistency assumptions and model discussion,
- tactic layer correctness interface over the trusted kernel.

= Traceability to Implementation

The specification is synchronized with implementation milestones:

- `src/kernel/types.mbt`: formal type representation and operations.
- `src/kernel/terms.mbt`: formal term representation and typing behavior.
- `src/kernel/thm.mbt`: theorem object and primitive inference core.

Future revisions should add a versioned change log section so each mathematical clause can be traced to concrete commits.
