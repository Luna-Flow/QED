// Generated using `moon info`, DON'T EDIT IT
package "Luna-Flow/QED/kernel"

// Values
pub fn abs_rule(Term, Thm) -> Thm?

pub fn assume(Term) -> Thm?

pub fn beta_rule(Term) -> Thm?

pub fn bool_ty() -> HolType

pub fn db_apply_ty_subst(Array[(String, HolType)], DbTerm) -> DbTerm

pub fn db_beta_reduce_once(DbTerm) -> DbTerm?

pub fn db_has_free(DbTerm, DbTerm) -> Bool

pub fn db_subst_free_parallel(DbTerm, Array[(DbTerm, DbTerm)]) -> DbTerm

pub fn db_term_eq(DbTerm, DbTerm) -> Bool

pub fn db_term_to_string(DbTerm) -> String

pub fn db_type_of(DbTerm) -> HolType?

pub fn deduct_antisym_rule(Thm, Thm) -> Thm?

pub fn dest_abs(Term) -> (Term, Term)?

pub fn dest_comb(Term) -> (Term, Term)?

pub fn dest_const(Term) -> (String, HolType)?

pub fn dest_eq(Term) -> (Term, Term)?

pub fn dest_fun_ty(HolType) -> (HolType, HolType)?

pub fn dest_tyapp(HolType) -> (String, Array[HolType])?

pub fn dest_var(Term) -> (String, HolType)?

pub fn empty_sig() -> GlobalSig

pub fn eq_mp(Thm, Thm) -> Thm?

pub fn from_db_term(DbTerm) -> Term?

pub fn fun_ty(HolType, HolType) -> HolType

pub fn hol_type_to_string(HolType) -> String

pub fn inst(Array[(Term, Term)], Thm) -> Thm?

pub fn inst_type(Array[(String, HolType)], Thm) -> Thm?

pub fn is_abs(Term) -> Bool

pub fn is_bool_ty(HolType) -> Bool

pub fn is_comb(Term) -> Bool

pub fn is_const(Term) -> Bool

pub fn is_tyapp(HolType) -> Bool

pub fn is_tyvar(HolType) -> Bool

pub fn is_var(Term) -> Bool

pub fn kernel_terms_phase0_ready() -> Bool

pub fn kernel_thm_phase0_ready() -> Bool

pub fn mk_abs(Term, Term) -> Term

pub fn mk_comb(Term, Term) -> Term

pub fn mk_comb_rule(Thm, Thm) -> Thm?

pub fn mk_const(String, HolType) -> Term

pub fn mk_eq(Term, Term) -> Term?

pub fn mk_tyapp(String, Array[HolType]) -> HolType

pub fn mk_tyvar(String) -> HolType

pub fn mk_var(String, HolType) -> Term

pub fn refl(Term) -> Thm?

pub fn sig_add_const(GlobalSig, String, HolType) -> GlobalSig?

pub fn sig_add_const_idempotent(GlobalSig, String, HolType) -> GlobalSig?

pub fn sig_add_const_idempotent_e(GlobalSig, String, HolType) -> Result[GlobalSig, SigError]

pub fn sig_define_const(GlobalSig, String, Term) -> (GlobalSig, Term)?

pub fn sig_define_const_e(GlobalSig, String, Term) -> Result[(GlobalSig, Term), SigError]

pub fn sig_has_const(GlobalSig, String) -> Bool

pub fn sig_lookup_const(GlobalSig, String) -> HolType?

pub fn sig_mk_const(GlobalSig, String) -> Term?

pub fn sig_mk_const_e(GlobalSig, String) -> Result[Term, SigError]

pub fn sig_pop_scope(GlobalSig) -> GlobalSig?

pub fn sig_pop_scope_e(GlobalSig) -> Result[GlobalSig, SigError]

pub fn sig_push_scope(GlobalSig) -> GlobalSig

pub fn term_alpha_eq(Term, Term) -> Bool

pub fn term_to_string(Term) -> String

pub fn to_db_term(Term) -> DbTerm?

pub fn trans(Thm, Thm) -> Thm?

pub fn ty_eq(HolType, HolType) -> Bool

pub fn type_of(Term) -> HolType?

// Errors

// Types and methods
pub enum DbTerm {
  DbBound(Int, HolType)
  DbFree(String, HolType)
  DbConst(String, HolType)
  DbComb(DbTerm, DbTerm)
  DbAbs(HolType, DbTerm)
}

pub enum GlobalSig {
  Sig(Array[Array[(String, HolType)]])
}

pub enum HolType {
  TyVal(String)
  TyApp(String, Array[HolType])
}

pub enum SigError {
  DuplicateConstName
  ConstTypeConflict
  UnknownConst
  ScopeUnderflow
  InvalidConstRhs
}

pub enum Term {
  Var(String, HolType)
  Const(String, HolType)
  Comb(Term, Term)
  Abs(Term, Term)
}

pub enum Thm {
  Sequent(Array[Term], Term)
}

// Type aliases

// Traits

