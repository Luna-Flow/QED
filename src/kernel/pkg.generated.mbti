// Generated using `moon info`, DON'T EDIT IT
package "Luna-Flow/QED/kernel"

// Values
pub fn abs_rule_checked(KernelState, Term, Thm) -> Result[Thm, LogicError]

pub fn assume_checked(KernelState, Term) -> Result[Thm, LogicError]

pub fn beta_rule_checked(KernelState, Term) -> Result[Thm, LogicError]

pub fn bool_ty() -> HolType

pub fn db_apply_ty_subst(Array[(String, HolType)], DbTerm) -> DbTerm

pub fn db_beta_reduce_once(DbTerm) -> DbTerm?

pub fn db_has_free(DbTerm, DbTerm) -> Bool

pub fn db_subst_free_parallel(DbTerm, Array[(DbTerm, DbTerm)]) -> DbTerm

pub fn db_term_eq(DbTerm, DbTerm) -> Bool

pub fn db_term_to_string(DbTerm) -> String

pub fn db_type_of(DbTerm) -> HolType?

pub fn deduct_antisym_rule_checked(KernelState, Thm, Thm) -> Result[Thm, LogicError]

pub fn dest_abs(Term) -> (Term, Term)?

pub fn dest_comb(Term) -> (Term, Term)?

pub fn dest_const(Term) -> (String, HolType)?

pub fn dest_eq(Term) -> Result[(Term, Term), LogicError]

pub fn dest_fun_ty(HolType) -> (HolType, HolType)?

pub fn dest_tyapp(HolType) -> (String, Array[HolType])?

pub fn dest_var(Term) -> (String, HolType)?

pub fn empty_kernel_state() -> KernelState

pub fn empty_sig() -> GlobalSig

pub fn eq_mp_checked(KernelState, Thm, Thm) -> Result[Thm, LogicError]

pub fn free_vars(Term) -> Array[(String, HolType)]

pub fn from_db_term(DbTerm) -> Term?

pub fn fun_ty(HolType, HolType) -> HolType

pub fn has_duplicate_ty_subst_keys(Array[(String, HolType)]) -> Bool

pub fn hol_type_to_string(HolType) -> String

pub fn inst_checked(KernelState, Array[(Term, Term)], Thm) -> Result[Thm, LogicError]

pub fn inst_type(KernelState, Array[(String, HolType)], Thm) -> Result[Thm, LogicError]

pub fn is_abs(Term) -> Bool

pub fn is_bool_ty(HolType) -> Bool

pub fn is_comb(Term) -> Bool

pub fn is_const(Term) -> Bool

pub fn is_tyapp(HolType) -> Bool

pub fn is_tyvar(HolType) -> Bool

pub fn is_var(Term) -> Bool

pub fn kernel_terms_phase0_ready() -> Bool

pub fn kernel_thm_phase0_ready() -> Bool

pub fn ks_add_const(KernelState, String, HolType) -> Result[KernelState, SigError]

pub fn ks_const_schema(KernelState, String) -> HolType?

pub fn ks_define_const(KernelState, String, HolType, Term) -> Result[(KernelState, Term), SigError]

pub fn ks_define_const_thm(KernelState, String, HolType, Term) -> Result[(KernelState, Thm), SigError]

pub fn ks_has_def_head(KernelState, String) -> Bool

pub fn ks_has_type_rep_head(KernelState, String) -> Bool

pub fn ks_has_type_witness(KernelState, String, Int) -> Bool

pub fn ks_lookup_const(KernelState, String) -> HolType?

pub fn ks_lookup_const_id(KernelState, String) -> Int?

pub fn ks_mk_const(KernelState, String) -> Result[Term, SigError]

pub fn ks_mk_const_instance(KernelState, String, HolType) -> Result[Term, SigError]

pub fn ks_pop_scope(KernelState) -> Result[KernelState, SigError]

pub fn ks_push_scope(KernelState) -> KernelState

pub fn ks_register_type_definition(KernelState, String, Array[String], String, Term, Thm) -> Result[KernelState, SigError]

pub fn ks_sig(KernelState) -> GlobalSig

pub fn ks_type_is_admissible(KernelState, HolType) -> Bool

pub fn ks_type_subst_is_admissible(KernelState, Array[(String, HolType)]) -> Bool

pub fn mk_abs(Term, Term) -> Term

pub fn mk_comb(Term, Term) -> Term

pub fn mk_comb_rule_checked(KernelState, Thm, Thm) -> Result[Thm, LogicError]

pub fn mk_const(String, HolType) -> Term

pub fn mk_eq(Term, Term) -> Result[Term, LogicError]

pub fn mk_tyapp(String, Array[HolType]) -> HolType

pub fn mk_tyvar(String) -> HolType

pub fn mk_var(String, HolType) -> Term

pub fn refl_checked(KernelState, Term) -> Result[Thm, LogicError]

pub fn sig_add_const_idempotent_e(GlobalSig, String, HolType) -> Result[GlobalSig, SigError]

pub fn sig_define_const_e(GlobalSig, String, Term) -> Result[(GlobalSig, Term), SigError]

pub fn sig_has_const(GlobalSig, String) -> Bool

pub fn sig_lookup_const(GlobalSig, String) -> HolType?

pub fn sig_lookup_const_id(GlobalSig, String) -> Int?

pub fn sig_mk_const_e(GlobalSig, String) -> Result[Term, SigError]

pub fn sig_mk_const_instance_e(GlobalSig, String, HolType) -> Result[Term, SigError]

pub fn sig_pop_scope_e(GlobalSig) -> Result[GlobalSig, SigError]

pub fn sig_push_scope(GlobalSig) -> GlobalSig

pub fn term_alpha_eq(Term, Term) -> Bool

pub fn term_apply_ty_subst(Array[(String, HolType)], Term) -> Term?

pub fn term_apply_ty_subst_unsafe(Array[(String, HolType)], Term) -> Term

pub fn term_has_const_named(Term, String) -> Bool

pub fn term_is_closed(Term) -> Bool

pub fn term_to_string(Term) -> String

pub fn term_tyvars(Term) -> Array[String]

pub fn term_tyvars_subset(Term, HolType) -> Bool

pub fn thm_bind_const_ids(KernelState, Thm) -> Result[Thm, LogicError]

pub fn thm_concl(Thm) -> Result[Term, LogicError]

pub fn thm_hyp_count(Thm) -> Int

pub fn thm_hyps(Thm) -> Result[Array[Term], LogicError]

pub fn thm_is_admissible(KernelState, Thm) -> Bool

pub fn thm_to_string(Thm) -> String

pub fn to_db_term(Term) -> DbTerm?

pub fn trans_checked(KernelState, Thm, Thm) -> Result[Thm, LogicError]

pub fn ty_eq(HolType, HolType) -> Bool

pub fn ty_is_instance_of(HolType, HolType) -> Bool

pub fn type_of(Term) -> HolType?

pub fn type_subst(Array[(String, HolType)], HolType) -> HolType?

pub fn type_subst_unsafe(Array[(String, HolType)], HolType) -> HolType

pub fn tyvars(HolType) -> Array[String]

pub fn tyvars_subset(HolType, HolType) -> Bool

// Errors
pub suberror LogicError {
  TypeMismatch
  VariableCaptured
  NotAnEquality
  NotBoolTerm
  AlphaMismatch
  InvalidInstantiation
  VarFreeInHyp
  NotTrivialBetaRedex
  BoundaryFailure
}

pub suberror SigError {
  DuplicateConstName
  ConstTypeConflict
  InvalidConstInstance
  UnknownConst
  ScopeUnderflow
  InvalidConstRhs
  ReservedSymbol
  DefinitionAlreadyExists
  DefinitionNotClosed
  DefinitionIsCyclic
  GhostTypeVariable
  InvalidTypeWitness
  InvalidTypePredicate
  InvalidTypeRepName
  InvalidTypeParams
  InvalidTypeArity
  TypeWitnessArityMismatch
  TypeWitnessPredicateMismatch
  TypeConstructorAlreadyExists
  TypeRepresentationAlreadyExists
  TypeMismatch
}

// Types and methods
pub enum DbTerm {
  DbBound(Int, HolType)
  DbFree(String, HolType)
  DbConst(String, HolType)
  DbComb(DbTerm, DbTerm)
  DbAbs(HolType, DbTerm)
}

pub enum GlobalSig {
  Sig(Array[Array[(String, Int, HolType)]])
}

pub enum HolType {
  TyVal(String)
  TyApp(String, Array[HolType])
}

type KernelState

pub enum Term {
  Var(String, HolType)
  Const(String, HolType)
  Comb(Term, Term)
  Abs(Term, Term)
}

type Thm

// Type aliases
pub type ConstId = Int

// Traits

